import {
  button_default
} from "./chunk-RQOCTJPE.js";
import {
  $40df3f8667284809$export$d55e7ee900f34e93,
  $fc909762b330b746$export$61c6a8c84e605fb6,
  useAriaOverlay
} from "./chunk-JRTATEOB.js";
import {
  useSafeLayoutEffect
} from "./chunk-D3V2XJSH.js";
import {
  TRANSITION_VARIANTS
} from "./chunk-VTGC4MY7.js";
import {
  useAriaButton
} from "./chunk-FYC375XV.js";
import {
  $2a41e45df1593e64$export$d39e1813b3bdd0e1,
  $337b884510726a0d$export$c6fdb837b070b4ff,
  $49c51c25361d4cd2$export$ee0f7cc6afcd1c18,
  $628037886ba31236$export$f9d5c8beee7d008d,
  $86ea4cb521eb2e37$export$2317d149ed6f78c4,
  $f7dceffc5ad7768b$export$4e328f61c538687f,
  clsx,
  createContext2,
  dataAttr,
  forwardRef,
  mapPropsVariants,
  mergeProps,
  mergeRefs,
  objectToDeps,
  pickChildren,
  popover,
  useDOMRef,
  useProviderContext
} from "./chunk-RXQPOJHA.js";
import {
  AnimatePresence,
  LazyMotion,
  m
} from "./chunk-2XL62SD4.js";
import {
  require_jsx_runtime
} from "./chunk-HOLCHQKJ.js";
import {
  require_react
} from "./chunk-BQYK6RGN.js";
import {
  __toESM
} from "./chunk-G3PMV62Z.js";

// node_modules/@react-stately/collections/dist/Item.mjs
var import_react = __toESM(require_react(), 1);
function $c1d7fb2ec91bae71$var$Item(props) {
  return null;
}
$c1d7fb2ec91bae71$var$Item.getCollectionNode = function* getCollectionNode(props, context) {
  let { childItems, title, children } = props;
  let rendered = props.title || props.children;
  let textValue = props.textValue || (typeof rendered === "string" ? rendered : "") || props["aria-label"] || "";
  if (!textValue && !(context === null || context === void 0 ? void 0 : context.suppressTextValueWarning) && true) console.warn("<Item> with non-plain text contents is unsupported by type to select for accessibility. Please add a `textValue` prop.");
  yield {
    type: "item",
    props,
    rendered,
    textValue,
    "aria-label": props["aria-label"],
    hasChildNodes: $c1d7fb2ec91bae71$var$hasChildItems(props),
    *childNodes() {
      if (childItems) for (let child of childItems) yield {
        type: "item",
        value: child
      };
      else if (title) {
        let items = [];
        (0, import_react.default).Children.forEach(children, (child) => {
          items.push({
            type: "item",
            element: child
          });
        });
        yield* items;
      }
    }
  };
};
function $c1d7fb2ec91bae71$var$hasChildItems(props) {
  if (props.hasChildItems != null) return props.hasChildItems;
  if (props.childItems) return true;
  if (props.title && (0, import_react.default).Children.count(props.children) > 0) return true;
  return false;
}
var $c1d7fb2ec91bae71$export$6d08773d2e66f8f2 = $c1d7fb2ec91bae71$var$Item;

// node_modules/@react-stately/collections/dist/Section.mjs
var import_react2 = __toESM(require_react(), 1);
function $9fc4852771d079eb$var$Section(props) {
  return null;
}
$9fc4852771d079eb$var$Section.getCollectionNode = function* getCollectionNode2(props) {
  let { children, title, items } = props;
  yield {
    type: "section",
    props,
    hasChildNodes: true,
    rendered: title,
    "aria-label": props["aria-label"],
    *childNodes() {
      if (typeof children === "function") {
        if (!items) throw new Error("props.children was a function but props.items is missing");
        for (let item of items) yield {
          type: "item",
          value: item,
          renderer: children
        };
      } else {
        let items2 = [];
        (0, import_react2.default).Children.forEach(children, (child) => {
          items2.push({
            type: "item",
            element: child
          });
        });
        yield* items2;
      }
    }
  };
};
var $9fc4852771d079eb$export$6e2c8f0811a474ce = $9fc4852771d079eb$var$Section;

// node_modules/@react-stately/collections/dist/CollectionBuilder.mjs
var import_react3 = __toESM(require_react(), 1);
var $eb2240fc39a57fa5$export$bf788dd355e3a401 = class {
  build(props, context) {
    this.context = context;
    return $eb2240fc39a57fa5$var$iterable(() => this.iterateCollection(props));
  }
  *iterateCollection(props) {
    let { children, items } = props;
    if ((0, import_react3.default).isValidElement(children) && children.type === (0, import_react3.default).Fragment) yield* this.iterateCollection({
      children: children.props.children,
      items
    });
    else if (typeof children === "function") {
      if (!items) throw new Error("props.children was a function but props.items is missing");
      let index = 0;
      for (let item of items) {
        yield* this.getFullNode({
          value: item,
          index
        }, {
          renderer: children
        });
        index++;
      }
    } else {
      let items2 = [];
      (0, import_react3.default).Children.forEach(children, (child) => {
        if (child) items2.push(child);
      });
      let index = 0;
      for (let item of items2) {
        let nodes = this.getFullNode({
          element: item,
          index
        }, {});
        for (let node of nodes) {
          index++;
          yield node;
        }
      }
    }
  }
  getKey(item, partialNode, state, parentKey) {
    if (item.key != null) return item.key;
    if (partialNode.type === "cell" && partialNode.key != null) return `${parentKey}${partialNode.key}`;
    let v = partialNode.value;
    if (v != null) {
      var _v_key;
      let key = (_v_key = v.key) !== null && _v_key !== void 0 ? _v_key : v.id;
      if (key == null) throw new Error("No key found for item");
      return key;
    }
    return parentKey ? `${parentKey}.${partialNode.index}` : `$.${partialNode.index}`;
  }
  getChildState(state, partialNode) {
    return {
      renderer: partialNode.renderer || state.renderer
    };
  }
  *getFullNode(partialNode, state, parentKey, parentNode) {
    if ((0, import_react3.default).isValidElement(partialNode.element) && partialNode.element.type === (0, import_react3.default).Fragment) {
      let children = [];
      (0, import_react3.default).Children.forEach(partialNode.element.props.children, (child) => {
        children.push(child);
      });
      var _partialNode_index;
      let index = (_partialNode_index = partialNode.index) !== null && _partialNode_index !== void 0 ? _partialNode_index : 0;
      for (const child of children) yield* this.getFullNode({
        element: child,
        index: index++
      }, state, parentKey, parentNode);
      return;
    }
    let element = partialNode.element;
    if (!element && partialNode.value && state && state.renderer) {
      let cached = this.cache.get(partialNode.value);
      if (cached && (!cached.shouldInvalidate || !cached.shouldInvalidate(this.context))) {
        cached.index = partialNode.index;
        cached.parentKey = parentNode ? parentNode.key : null;
        yield cached;
        return;
      }
      element = state.renderer(partialNode.value);
    }
    if ((0, import_react3.default).isValidElement(element)) {
      let type = element.type;
      if (typeof type !== "function" && typeof type.getCollectionNode !== "function") {
        let name = element.type;
        throw new Error(`Unknown element <${name}> in collection.`);
      }
      let childNodes = type.getCollectionNode(element.props, this.context);
      var _partialNode_index1;
      let index = (_partialNode_index1 = partialNode.index) !== null && _partialNode_index1 !== void 0 ? _partialNode_index1 : 0;
      let result = childNodes.next();
      while (!result.done && result.value) {
        let childNode = result.value;
        partialNode.index = index;
        var _childNode_key;
        let nodeKey = (_childNode_key = childNode.key) !== null && _childNode_key !== void 0 ? _childNode_key : null;
        if (nodeKey == null) nodeKey = childNode.element ? null : this.getKey(element, partialNode, state, parentKey);
        let nodes = this.getFullNode({
          ...childNode,
          key: nodeKey,
          index,
          wrapper: $eb2240fc39a57fa5$var$compose(partialNode.wrapper, childNode.wrapper)
        }, this.getChildState(state, childNode), parentKey ? `${parentKey}${element.key}` : element.key, parentNode);
        let children = [
          ...nodes
        ];
        for (let node2 of children) {
          var _childNode_value, _ref;
          node2.value = (_ref = (_childNode_value = childNode.value) !== null && _childNode_value !== void 0 ? _childNode_value : partialNode.value) !== null && _ref !== void 0 ? _ref : null;
          if (node2.value) this.cache.set(node2.value, node2);
          var _parentNode_type;
          if (partialNode.type && node2.type !== partialNode.type) throw new Error(`Unsupported type <${$eb2240fc39a57fa5$var$capitalize(node2.type)}> in <${$eb2240fc39a57fa5$var$capitalize((_parentNode_type = parentNode === null || parentNode === void 0 ? void 0 : parentNode.type) !== null && _parentNode_type !== void 0 ? _parentNode_type : "unknown parent type")}>. Only <${$eb2240fc39a57fa5$var$capitalize(partialNode.type)}> is supported.`);
          index++;
          yield node2;
        }
        result = childNodes.next(children);
      }
      return;
    }
    if (partialNode.key == null || partialNode.type == null) return;
    let builder = this;
    var _partialNode_value, _partialNode_textValue;
    let node = {
      type: partialNode.type,
      props: partialNode.props,
      key: partialNode.key,
      parentKey: parentNode ? parentNode.key : null,
      value: (_partialNode_value = partialNode.value) !== null && _partialNode_value !== void 0 ? _partialNode_value : null,
      level: parentNode ? parentNode.level + 1 : 0,
      index: partialNode.index,
      rendered: partialNode.rendered,
      textValue: (_partialNode_textValue = partialNode.textValue) !== null && _partialNode_textValue !== void 0 ? _partialNode_textValue : "",
      "aria-label": partialNode["aria-label"],
      wrapper: partialNode.wrapper,
      shouldInvalidate: partialNode.shouldInvalidate,
      hasChildNodes: partialNode.hasChildNodes || false,
      childNodes: $eb2240fc39a57fa5$var$iterable(function* () {
        if (!partialNode.hasChildNodes || !partialNode.childNodes) return;
        let index = 0;
        for (let child of partialNode.childNodes()) {
          if (child.key != null)
            child.key = `${node.key}${child.key}`;
          let nodes = builder.getFullNode({
            ...child,
            index
          }, builder.getChildState(state, child), node.key, node);
          for (let node2 of nodes) {
            index++;
            yield node2;
          }
        }
      })
    };
    yield node;
  }
  constructor() {
    this.cache = /* @__PURE__ */ new WeakMap();
  }
};
function $eb2240fc39a57fa5$var$iterable(iterator) {
  let cache = [];
  let iterable = null;
  return {
    *[Symbol.iterator]() {
      for (let item of cache) yield item;
      if (!iterable) iterable = iterator();
      for (let item of iterable) {
        cache.push(item);
        yield item;
      }
    }
  };
}
function $eb2240fc39a57fa5$var$compose(outer, inner) {
  if (outer && inner) return (element) => outer(inner(element));
  if (outer) return outer;
  if (inner) return inner;
}
function $eb2240fc39a57fa5$var$capitalize(str) {
  return str[0].toUpperCase() + str.slice(1);
}

// node_modules/@react-stately/collections/dist/useCollection.mjs
var import_react4 = __toESM(require_react(), 1);
function $7613b1592d41b092$export$6cd28814d92fa9c9(props, factory, context) {
  let builder = (0, import_react4.useMemo)(() => new (0, $eb2240fc39a57fa5$export$bf788dd355e3a401)(), []);
  let { children, items, collection } = props;
  let result = (0, import_react4.useMemo)(() => {
    if (collection) return collection;
    let nodes = builder.build({
      children,
      items
    }, context);
    return factory(nodes);
  }, [
    builder,
    children,
    items,
    collection,
    context,
    factory
  ]);
  return result;
}

// node_modules/@react-stately/collections/dist/getChildNodes.mjs
function $c5a24bc478652b5f$export$1005530eda016c13(node, collection) {
  if (typeof collection.getChildren === "function") return collection.getChildren(node.key);
  return node.childNodes;
}
function $c5a24bc478652b5f$export$fbdeaa6a76694f71(iterable) {
  return $c5a24bc478652b5f$export$5f3398f8733f90e2(iterable, 0);
}
function $c5a24bc478652b5f$export$5f3398f8733f90e2(iterable, index) {
  if (index < 0) return void 0;
  let i = 0;
  for (let item of iterable) {
    if (i === index) return item;
    i++;
  }
}
function $c5a24bc478652b5f$export$8c434b3a7a4dad6(collection, a, b) {
  if (a.parentKey === b.parentKey) return a.index - b.index;
  let aAncestors = [
    ...$c5a24bc478652b5f$var$getAncestors(collection, a),
    a
  ];
  let bAncestors = [
    ...$c5a24bc478652b5f$var$getAncestors(collection, b),
    b
  ];
  let firstNonMatchingAncestor = aAncestors.slice(0, bAncestors.length).findIndex((a2, i) => a2 !== bAncestors[i]);
  if (firstNonMatchingAncestor !== -1) {
    a = aAncestors[firstNonMatchingAncestor];
    b = bAncestors[firstNonMatchingAncestor];
    return a.index - b.index;
  }
  if (aAncestors.findIndex((node) => node === b) >= 0) return 1;
  else if (bAncestors.findIndex((node) => node === a) >= 0) return -1;
  return -1;
}
function $c5a24bc478652b5f$var$getAncestors(collection, node) {
  let parents = [];
  let currNode = node;
  while ((currNode === null || currNode === void 0 ? void 0 : currNode.parentKey) != null) {
    currNode = collection.getItem(currNode.parentKey);
    if (currNode) parents.unshift(currNode);
  }
  return parents;
}

// node_modules/@react-stately/collections/dist/getItemCount.mjs
var $453cc9f0df89c0a5$var$cache = /* @__PURE__ */ new WeakMap();
function $453cc9f0df89c0a5$export$77d5aafae4e095b2(collection) {
  let count = $453cc9f0df89c0a5$var$cache.get(collection);
  if (count != null) return count;
  let counter = 0;
  let countItems = (items) => {
    for (let item of items) {
      if (item.type === "section") countItems((0, $c5a24bc478652b5f$export$1005530eda016c13)(item, collection));
      else if (item.type === "item") counter++;
    }
  };
  countItems(collection);
  $453cc9f0df89c0a5$var$cache.set(collection, counter);
  return counter;
}

// node_modules/@heroui/aria-utils/dist/chunk-WQVQ7P2I.mjs
var getTransformOrigins = (placement) => {
  const origins = {
    top: {
      originY: 1
    },
    bottom: {
      originY: 0
    },
    left: {
      originX: 1
    },
    right: {
      originX: 0
    },
    "top-start": {
      originX: 0,
      originY: 1
    },
    "top-end": {
      originX: 1,
      originY: 1
    },
    "bottom-start": {
      originX: 0,
      originY: 0
    },
    "bottom-end": {
      originX: 1,
      originY: 0
    },
    "right-start": {
      originX: 0,
      originY: 0
    },
    "right-end": {
      originX: 0,
      originY: 1
    },
    "left-start": {
      originX: 1,
      originY: 0
    },
    "left-end": {
      originX: 1,
      originY: 1
    }
  };
  return (origins == null ? void 0 : origins[placement]) || {};
};
var toReactAriaPlacement = (placement) => {
  const mapPositions = {
    top: "top",
    bottom: "bottom",
    left: "left",
    right: "right",
    "top-start": "top start",
    "top-end": "top end",
    "bottom-start": "bottom start",
    "bottom-end": "bottom end",
    "left-start": "left top",
    "left-end": "left bottom",
    "right-start": "right top",
    "right-end": "right bottom"
  };
  return mapPositions[placement];
};
var getShouldUseAxisPlacement = (axisPlacement, overlayPlacement) => {
  if (overlayPlacement.includes("-")) {
    const [position] = overlayPlacement.split("-");
    if (position.includes(axisPlacement)) {
      return false;
    }
  }
  return true;
};
var getArrowPlacement = (dynamicPlacement, placement) => {
  if (placement.includes("-")) {
    const [, position] = placement.split("-");
    return `${dynamicPlacement}-${position}`;
  }
  return dynamicPlacement;
};

// node_modules/@heroui/aria-utils/dist/chunk-YVW4JKAM.mjs
var refCountMap = /* @__PURE__ */ new WeakMap();
var observerStack = [];
function ariaHideOutside(targets, root = document.body) {
  let visibleNodes = new Set(targets);
  let hiddenNodes = /* @__PURE__ */ new Set();
  let walk = (root2) => {
    for (let element of root2.querySelectorAll(
      "[data-live-announcer], [data-react-aria-top-layer]"
    )) {
      visibleNodes.add(element);
    }
    let acceptNode = (node) => {
      if (visibleNodes.has(node) || node.parentElement && hiddenNodes.has(node.parentElement) && node.parentElement.getAttribute("role") !== "row") {
        return NodeFilter.FILTER_REJECT;
      }
      for (let target of visibleNodes) {
        if (node.contains(target)) {
          return NodeFilter.FILTER_SKIP;
        }
      }
      return NodeFilter.FILTER_ACCEPT;
    };
    let walker = document.createTreeWalker(root2, NodeFilter.SHOW_ELEMENT, { acceptNode });
    let acceptRoot = acceptNode(root2);
    if (acceptRoot === NodeFilter.FILTER_ACCEPT) {
      hide(root2);
    }
    if (acceptRoot !== NodeFilter.FILTER_REJECT) {
      let node = walker.nextNode();
      while (node != null) {
        hide(node);
        node = walker.nextNode();
      }
    }
  };
  let hide = (node) => {
    var _a;
    let refCount = (_a = refCountMap.get(node)) != null ? _a : 0;
    if (node.getAttribute("aria-hidden") === "true" && refCount === 0) {
      return;
    }
    if (refCount === 0) {
      node.setAttribute("aria-hidden", "true");
    }
    hiddenNodes.add(node);
    refCountMap.set(node, refCount + 1);
  };
  if (observerStack.length) {
    observerStack[observerStack.length - 1].disconnect();
  }
  walk(root);
  let observer = new MutationObserver((changes) => {
    for (let change of changes) {
      if (change.type !== "childList" || change.addedNodes.length === 0) {
        continue;
      }
      if (![...visibleNodes, ...hiddenNodes].some((node) => node.contains(change.target))) {
        for (let node of change.removedNodes) {
          if (node instanceof Element) {
            visibleNodes.delete(node);
            hiddenNodes.delete(node);
          }
        }
        for (let node of change.addedNodes) {
          if ((node instanceof HTMLElement || node instanceof SVGElement) && (node.dataset.liveAnnouncer === "true" || node.dataset.reactAriaTopLayer === "true")) {
            visibleNodes.add(node);
          } else if (node instanceof Element) {
            walk(node);
          }
        }
      }
    }
  });
  observer.observe(root, { childList: true, subtree: true });
  let observerWrapper = {
    visibleNodes,
    hiddenNodes,
    observe() {
      observer.observe(root, { childList: true, subtree: true });
    },
    disconnect() {
      observer.disconnect();
    }
  };
  observerStack.push(observerWrapper);
  return () => {
    observer.disconnect();
    for (let node of hiddenNodes) {
      let count = refCountMap.get(node);
      if (count == null) {
        continue;
      }
      if (count === 1) {
        node.removeAttribute("aria-hidden");
        refCountMap.delete(node);
      } else {
        refCountMap.set(node, count - 1);
      }
    }
    if (observerWrapper === observerStack[observerStack.length - 1]) {
      observerStack.pop();
      if (observerStack.length) {
        observerStack[observerStack.length - 1].observe();
      }
    } else {
      observerStack.splice(observerStack.indexOf(observerWrapper), 1);
    }
  };
}
function keepVisible(element) {
  let observer = observerStack[observerStack.length - 1];
  if (observer && !observer.visibleNodes.has(element)) {
    observer.visibleNodes.add(element);
    return () => {
      observer.visibleNodes.delete(element);
    };
  }
}

// node_modules/@heroui/popover/dist/chunk-7N5ZXA6H.mjs
var import_react5 = __toESM(require_react(), 1);
function useReactAriaPopover(props, state) {
  const {
    groupRef,
    triggerRef,
    popoverRef,
    showArrow,
    offset = 7,
    crossOffset = 0,
    scrollRef,
    shouldFlip,
    boundaryElement,
    isDismissable = true,
    shouldCloseOnBlur = true,
    shouldCloseOnScroll = true,
    placement: placementProp = "top",
    containerPadding,
    shouldCloseOnInteractOutside,
    isNonModal: isNonModalProp,
    isKeyboardDismissDisabled,
    updatePositionDeps = [],
    ...otherProps
  } = props;
  const isNonModal = isNonModalProp != null ? isNonModalProp : true;
  const isSubmenu = otherProps["trigger"] === "SubmenuTrigger";
  const { overlayProps, underlayProps } = useAriaOverlay(
    {
      isOpen: state.isOpen,
      onClose: state.close,
      shouldCloseOnBlur,
      isDismissable: isDismissable || isSubmenu,
      isKeyboardDismissDisabled,
      shouldCloseOnInteractOutside: shouldCloseOnInteractOutside || ((el) => {
        var _a;
        return !((_a = triggerRef.current) == null ? void 0 : _a.contains(el));
      }),
      disableOutsideEvents: !isNonModal
    },
    popoverRef
  );
  const {
    overlayProps: positionProps,
    arrowProps,
    placement,
    updatePosition,
    triggerAnchorPoint: origin
  } = $2a41e45df1593e64$export$d39e1813b3bdd0e1({
    ...otherProps,
    shouldFlip,
    crossOffset,
    targetRef: triggerRef,
    overlayRef: popoverRef,
    isOpen: state.isOpen,
    scrollRef,
    boundaryElement,
    containerPadding,
    placement: toReactAriaPlacement(placementProp),
    offset: showArrow ? offset + 3 : offset,
    onClose: isNonModal && !isSubmenu && shouldCloseOnScroll ? state.close : () => {
    }
  });
  useSafeLayoutEffect(() => {
    if (!updatePositionDeps.length) return;
    updatePosition();
  }, updatePositionDeps);
  (0, import_react5.useEffect)(() => {
    var _a, _b;
    if (state.isOpen && popoverRef.current) {
      if (isNonModal) {
        return keepVisible((_a = groupRef == null ? void 0 : groupRef.current) != null ? _a : popoverRef.current);
      } else {
        return ariaHideOutside([(_b = groupRef == null ? void 0 : groupRef.current) != null ? _b : popoverRef.current]);
      }
    }
  }, [isNonModal, state.isOpen, popoverRef, groupRef]);
  return {
    popoverProps: mergeProps(overlayProps, positionProps),
    arrowProps,
    underlayProps,
    placement,
    triggerAnchorPoint: origin
  };
}

// node_modules/@heroui/popover/dist/chunk-HGFRVVZK.mjs
var import_react6 = __toESM(require_react(), 1);
var DEFAULT_PLACEMENT = "top";
function usePopover(originalProps) {
  var _a, _b, _c;
  const globalContext = useProviderContext();
  const [props, variantProps] = mapPropsVariants(originalProps, popover.variantKeys);
  const {
    as,
    ref,
    children,
    state: stateProp,
    triggerRef: triggerRefProp,
    scrollRef,
    defaultOpen,
    onOpenChange,
    isOpen: isOpenProp,
    isNonModal = true,
    shouldFlip = true,
    containerPadding = 12,
    shouldBlockScroll = false,
    isDismissable = true,
    shouldCloseOnBlur,
    portalContainer,
    updatePositionDeps,
    dialogProps: dialogPropsProp,
    placement: placementProp = DEFAULT_PLACEMENT,
    triggerType = "dialog",
    showArrow = false,
    offset = 7,
    crossOffset = 0,
    boundaryElement,
    isKeyboardDismissDisabled,
    shouldCloseOnInteractOutside,
    shouldCloseOnScroll,
    triggerAnchorPoint,
    motionProps,
    className,
    classNames,
    onClose,
    ...otherProps
  } = props;
  const Component = as || "div";
  const domRef = useDOMRef(ref);
  const domTriggerRef = (0, import_react6.useRef)(null);
  const wasTriggerPressedRef = (0, import_react6.useRef)(false);
  const triggerRef = triggerRefProp || domTriggerRef;
  const disableAnimation = (_b = (_a = originalProps.disableAnimation) != null ? _a : globalContext == null ? void 0 : globalContext.disableAnimation) != null ? _b : false;
  const innerState = $fc909762b330b746$export$61c6a8c84e605fb6({
    isOpen: isOpenProp,
    defaultOpen,
    onOpenChange: (isOpen) => {
      onOpenChange == null ? void 0 : onOpenChange(isOpen);
      if (!isOpen) {
        onClose == null ? void 0 : onClose();
      }
    }
  });
  const state = stateProp || innerState;
  const {
    popoverProps,
    underlayProps,
    placement: ariaPlacement
  } = useReactAriaPopover(
    {
      triggerRef,
      isNonModal,
      popoverRef: domRef,
      placement: placementProp,
      offset,
      scrollRef,
      isDismissable,
      shouldCloseOnBlur,
      boundaryElement,
      crossOffset,
      shouldFlip,
      containerPadding,
      updatePositionDeps,
      isKeyboardDismissDisabled,
      shouldCloseOnScroll,
      shouldCloseOnInteractOutside,
      triggerAnchorPoint
    },
    state
  );
  const placement = (0, import_react6.useMemo)(() => {
    if (!ariaPlacement) {
      return null;
    }
    return getShouldUseAxisPlacement(ariaPlacement, placementProp) ? ariaPlacement : placementProp;
  }, [ariaPlacement, placementProp]);
  const { triggerProps } = $628037886ba31236$export$f9d5c8beee7d008d({ type: triggerType }, state, triggerRef);
  const { isFocusVisible, isFocused, focusProps } = $f7dceffc5ad7768b$export$4e328f61c538687f();
  const slots = (0, import_react6.useMemo)(
    () => popover({
      ...variantProps
    }),
    [objectToDeps(variantProps)]
  );
  const baseStyles = clsx(classNames == null ? void 0 : classNames.base, className);
  const anchorStyles = {
    "--trigger-anchor-point": triggerAnchorPoint ? `${triggerAnchorPoint.x}px ${triggerAnchorPoint.y}px` : void 0
  };
  $49c51c25361d4cd2$export$ee0f7cc6afcd1c18({
    isDisabled: !(shouldBlockScroll && state.isOpen)
  });
  const getPopoverProps = (props2 = {}) => ({
    ref: domRef,
    ...mergeProps(popoverProps, otherProps, props2),
    style: mergeProps(popoverProps.style, otherProps.style, props2.style)
  });
  const getDialogProps = (props2 = {}) => ({
    // `ref` and `dialogProps` from `useDialog` are passed from props
    // if we use `useDialog` here, dialogRef won't be focused on mount
    "data-slot": "base",
    "data-open": dataAttr(state.isOpen),
    "data-focus": dataAttr(isFocused),
    "data-arrow": dataAttr(showArrow),
    "data-focus-visible": dataAttr(isFocusVisible),
    "data-placement": ariaPlacement ? getArrowPlacement(ariaPlacement, placementProp) : void 0,
    ...mergeProps(focusProps, dialogPropsProp, props2),
    className: slots.base({ class: clsx(baseStyles) }),
    style: {
      // this prevent the dialog to have a default outline
      outline: "none",
      ...anchorStyles
    }
  });
  const getContentProps = (0, import_react6.useCallback)(
    (props2 = {}) => ({
      "data-slot": "content",
      "data-open": dataAttr(state.isOpen),
      "data-arrow": dataAttr(showArrow),
      "data-placement": ariaPlacement ? getArrowPlacement(ariaPlacement, placementProp) : void 0,
      className: slots.content({ class: clsx(classNames == null ? void 0 : classNames.content, props2.className) })
    }),
    [slots, state.isOpen, showArrow, placement, placementProp, classNames, ariaPlacement]
  );
  const onPress = (0, import_react6.useCallback)(
    (e) => {
      var _a2;
      let pressTimer;
      if (e.pointerType === "touch" && ((originalProps == null ? void 0 : originalProps.backdrop) === "blur" || (originalProps == null ? void 0 : originalProps.backdrop) === "opaque")) {
        pressTimer = setTimeout(() => {
          wasTriggerPressedRef.current = true;
        }, 100);
      } else {
        wasTriggerPressedRef.current = true;
      }
      (_a2 = triggerProps.onPress) == null ? void 0 : _a2.call(triggerProps, e);
      return () => {
        clearTimeout(pressTimer);
      };
    },
    [triggerProps == null ? void 0 : triggerProps.onPress]
  );
  const getTriggerProps = (0, import_react6.useCallback)(
    (props2 = {}, _ref = null) => {
      const { isDisabled, ...otherProps2 } = props2;
      return {
        "data-slot": "trigger",
        ...mergeProps({ "aria-haspopup": "dialog" }, triggerProps, otherProps2),
        onPress,
        isDisabled,
        className: slots.trigger({
          class: clsx(classNames == null ? void 0 : classNames.trigger, props2.className),
          // apply isDisabled class names to make the trigger child disabled
          // e.g. for elements like div or HeroUI elements that don't have `isDisabled` prop
          isTriggerDisabled: isDisabled
        }),
        ref: mergeRefs(_ref, triggerRef)
      };
    },
    [state, triggerProps, onPress, triggerRef]
  );
  const getBackdropProps = (0, import_react6.useCallback)(
    (props2 = {}) => ({
      "data-slot": "backdrop",
      className: slots.backdrop({ class: classNames == null ? void 0 : classNames.backdrop }),
      onClick: (e) => {
        if (!wasTriggerPressedRef.current) {
          e.preventDefault();
          return;
        }
        state.close();
        wasTriggerPressedRef.current = false;
      },
      ...underlayProps,
      ...props2
    }),
    [slots, state.isOpen, classNames, underlayProps]
  );
  return {
    state,
    Component,
    children,
    classNames,
    showArrow,
    triggerRef,
    placement,
    isNonModal,
    popoverRef: domRef,
    portalContainer,
    isOpen: state.isOpen,
    onClose: state.close,
    disableAnimation,
    shouldBlockScroll,
    backdrop: (_c = originalProps.backdrop) != null ? _c : "transparent",
    motionProps,
    getBackdropProps,
    getPopoverProps,
    getTriggerProps,
    getDialogProps,
    getContentProps
  };
}

// node_modules/@heroui/popover/dist/chunk-YK32CXJV.mjs
var React = __toESM(require_react(), 1);
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var domAnimation = () => import("./dist-ADIZCUMX.js").then((res) => res.default);
var FreeSoloPopoverWrapper = forwardRef(
  ({
    children,
    motionProps,
    placement,
    disableAnimation,
    style: styleProp = {},
    transformOrigin = {},
    ...otherProps
  }, ref) => {
    let style = styleProp;
    if (transformOrigin.originX !== void 0 || transformOrigin.originY !== void 0) {
      style = {
        ...style,
        // @ts-ignore
        transformOrigin
      };
    } else if (placement) {
      style = {
        ...style,
        ...getTransformOrigins(placement === "center" ? "top" : placement)
      };
    }
    return disableAnimation ? (0, import_jsx_runtime.jsx)("div", { ...otherProps, ref, children }) : (0, import_jsx_runtime.jsx)(LazyMotion, { features: domAnimation, children: (0, import_jsx_runtime.jsx)(
      m.div,
      {
        ref,
        animate: "enter",
        exit: "exit",
        initial: "initial",
        style,
        variants: TRANSITION_VARIANTS.scaleSpringOpacity,
        ...mergeProps(otherProps, motionProps),
        children
      }
    ) });
  }
);
FreeSoloPopoverWrapper.displayName = "HeroUI.FreeSoloPopoverWrapper";
var FreeSoloPopover = forwardRef(
  ({ children, transformOrigin, disableDialogFocus = false, ...props }, ref) => {
    const {
      Component,
      state,
      placement,
      backdrop,
      portalContainer,
      disableAnimation,
      motionProps,
      isNonModal,
      getPopoverProps,
      getBackdropProps,
      getDialogProps,
      getContentProps
    } = usePopover({
      ...props,
      ref
    });
    const dialogRef = React.useRef(null);
    const { dialogProps: ariaDialogProps, titleProps } = $40df3f8667284809$export$d55e7ee900f34e93({}, dialogRef);
    const dialogProps = getDialogProps({
      // by default, focus is moved into the dialog on mount
      // we can use `disableDialogFocus` to disable this behaviour
      // e.g. in autocomplete, the focus should be moved to the input (handled in autocomplete hook) instead of the dialog first
      ...!disableDialogFocus && { ref: dialogRef },
      ...ariaDialogProps
    });
    const backdropContent = React.useMemo(() => {
      if (backdrop === "transparent") {
        return null;
      }
      if (disableAnimation) {
        return (0, import_jsx_runtime.jsx)("div", { ...getBackdropProps() });
      }
      return (0, import_jsx_runtime.jsx)(LazyMotion, { features: domAnimation, children: (0, import_jsx_runtime.jsx)(
        m.div,
        {
          animate: "enter",
          exit: "exit",
          initial: "exit",
          variants: TRANSITION_VARIANTS.fade,
          ...getBackdropProps()
        }
      ) });
    }, [backdrop, disableAnimation, getBackdropProps]);
    return (0, import_jsx_runtime.jsxs)($337b884510726a0d$export$c6fdb837b070b4ff, { portalContainer, children: [
      !isNonModal && backdropContent,
      (0, import_jsx_runtime.jsx)(Component, { ...getPopoverProps(), children: (0, import_jsx_runtime.jsxs)(
        FreeSoloPopoverWrapper,
        {
          disableAnimation,
          motionProps,
          placement,
          tabIndex: -1,
          transformOrigin,
          ...dialogProps,
          children: [
            !isNonModal && (0, import_jsx_runtime.jsx)($86ea4cb521eb2e37$export$2317d149ed6f78c4, { onDismiss: state.close }),
            (0, import_jsx_runtime.jsx)("div", { ...getContentProps(), children: typeof children === "function" ? children(titleProps) : children }),
            (0, import_jsx_runtime.jsx)($86ea4cb521eb2e37$export$2317d149ed6f78c4, { onDismiss: state.close })
          ]
        }
      ) })
    ] });
  }
);
FreeSoloPopover.displayName = "HeroUI.FreeSoloPopover";
var free_solo_popover_default = FreeSoloPopover;

// node_modules/@heroui/popover/dist/chunk-CGIRYUEE.mjs
var [PopoverProvider, usePopoverContext] = createContext2({
  name: "PopoverContext",
  errorMessage: "usePopoverContext: `context` is undefined. Seems you forgot to wrap all popover components within `<Popover />`"
});

// node_modules/@heroui/popover/dist/chunk-Z57F4COC.mjs
var import_react7 = __toESM(require_react(), 1);
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var domAnimation2 = () => import("./dist-ADIZCUMX.js").then((res) => res.default);
var PopoverContent = (props) => {
  const { as, children, className, ...otherProps } = props;
  const {
    Component: OverlayComponent,
    placement,
    backdrop,
    motionProps,
    disableAnimation,
    getPopoverProps,
    getDialogProps,
    getBackdropProps,
    getContentProps,
    isNonModal,
    onClose
  } = usePopoverContext();
  const dialogRef = (0, import_react7.useRef)(null);
  const { dialogProps: ariaDialogProps, titleProps } = $40df3f8667284809$export$d55e7ee900f34e93({}, dialogRef);
  const dialogProps = getDialogProps({
    ref: dialogRef,
    ...ariaDialogProps,
    ...otherProps
  });
  const Component = as || OverlayComponent || "div";
  const content = children && (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [
    !isNonModal && (0, import_jsx_runtime2.jsx)($86ea4cb521eb2e37$export$2317d149ed6f78c4, { onDismiss: onClose }),
    (0, import_jsx_runtime2.jsx)(Component, { ...dialogProps, children: (0, import_jsx_runtime2.jsx)("div", { ...getContentProps({ className }), children: typeof children === "function" ? children(titleProps) : children }) }),
    (0, import_jsx_runtime2.jsx)($86ea4cb521eb2e37$export$2317d149ed6f78c4, { onDismiss: onClose })
  ] });
  const backdropContent = (0, import_react7.useMemo)(() => {
    if (backdrop === "transparent") {
      return null;
    }
    if (disableAnimation) {
      return (0, import_jsx_runtime2.jsx)("div", { ...getBackdropProps() });
    }
    return (0, import_jsx_runtime2.jsx)(LazyMotion, { features: domAnimation2, children: (0, import_jsx_runtime2.jsx)(
      m.div,
      {
        animate: "enter",
        exit: "exit",
        initial: "exit",
        variants: TRANSITION_VARIANTS.fade,
        ...getBackdropProps()
      }
    ) });
  }, [backdrop, disableAnimation, getBackdropProps]);
  const style = placement ? getTransformOrigins(placement === "center" ? "top" : placement) : void 0;
  const contents = (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, { children: disableAnimation ? content : (0, import_jsx_runtime2.jsx)(LazyMotion, { features: domAnimation2, children: (0, import_jsx_runtime2.jsx)(
    m.div,
    {
      animate: "enter",
      exit: "exit",
      initial: "initial",
      style,
      variants: TRANSITION_VARIANTS.scaleSpringOpacity,
      ...motionProps,
      children: content
    }
  ) }) });
  return (0, import_jsx_runtime2.jsxs)("div", { ...getPopoverProps(), children: [
    backdropContent,
    contents
  ] });
};
PopoverContent.displayName = "HeroUI.PopoverContent";
var popover_content_default = PopoverContent;

// node_modules/@heroui/popover/dist/chunk-6FXDB7ZT.mjs
var import_react8 = __toESM(require_react(), 1);
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
var PopoverTrigger = (props) => {
  var _a;
  const { triggerRef, getTriggerProps } = usePopoverContext();
  const { children, ...otherProps } = props;
  const child = (0, import_react8.useMemo)(() => {
    if (typeof children === "string") return (0, import_jsx_runtime3.jsx)("p", { children });
    return import_react8.Children.only(children);
  }, [children]);
  const childRef = (_a = child.props.ref) != null ? _a : child.ref;
  const { onPress, isDisabled, ...restProps } = (0, import_react8.useMemo)(() => {
    return getTriggerProps(mergeProps(otherProps, child.props), childRef);
  }, [getTriggerProps, child.props, otherProps, childRef]);
  const [, triggerChildren] = pickChildren(children, button_default);
  const { buttonProps } = useAriaButton({ onPress, isDisabled }, triggerRef);
  const hasHeroUIButton = (0, import_react8.useMemo)(() => {
    return (triggerChildren == null ? void 0 : triggerChildren[0]) !== void 0;
  }, [triggerChildren]);
  if (!hasHeroUIButton) {
    delete restProps["preventFocusOnPress"];
  }
  return (0, import_react8.cloneElement)(
    child,
    mergeProps(restProps, hasHeroUIButton ? { onPress, isDisabled } : buttonProps)
  );
};
PopoverTrigger.displayName = "HeroUI.PopoverTrigger";
var popover_trigger_default = PopoverTrigger;

// node_modules/@heroui/popover/dist/chunk-QWTMPRXH.mjs
var import_react9 = __toESM(require_react(), 1);
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
var Popover = forwardRef((props, ref) => {
  const { children, ...otherProps } = props;
  const context = usePopover({ ...otherProps, ref });
  const [trigger, content] = import_react9.Children.toArray(children);
  const overlay = (0, import_jsx_runtime4.jsx)($337b884510726a0d$export$c6fdb837b070b4ff, { portalContainer: context.portalContainer, children: content });
  return (0, import_jsx_runtime4.jsxs)(PopoverProvider, { value: context, children: [
    trigger,
    context.disableAnimation && context.isOpen ? overlay : (0, import_jsx_runtime4.jsx)(AnimatePresence, { children: context.isOpen ? overlay : null })
  ] });
});
Popover.displayName = "HeroUI.Popover";
var popover_default = Popover;

export {
  $c1d7fb2ec91bae71$export$6d08773d2e66f8f2,
  $9fc4852771d079eb$export$6e2c8f0811a474ce,
  $7613b1592d41b092$export$6cd28814d92fa9c9,
  $c5a24bc478652b5f$export$1005530eda016c13,
  $c5a24bc478652b5f$export$fbdeaa6a76694f71,
  $c5a24bc478652b5f$export$8c434b3a7a4dad6,
  $453cc9f0df89c0a5$export$77d5aafae4e095b2,
  usePopover,
  free_solo_popover_default,
  PopoverProvider,
  usePopoverContext,
  popover_content_default,
  popover_trigger_default,
  popover_default
};
//# sourceMappingURL=chunk-5UJVJW5M.js.map
